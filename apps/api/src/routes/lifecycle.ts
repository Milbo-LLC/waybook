import { zValidator } from "@hono/zod-validator";
import {
  createActivityVoteInputSchema,
  createChecklistItemInputSchema,
  createDestinationInputSchema,
  createDestinationVoteInputSchema,
  createTripMessageInputSchema,
  embeddedCheckoutCompleteInputSchema,
  embeddedCheckoutSessionInputSchema,
  runActivityResearchInputSchema,
  staysRecommendInputSchema,
  updateActivityStatusInputSchema,
  updateChecklistItemInputSchema
} from "@waybook/contracts";
import { schema } from "@waybook/db";
import { and, asc, count, desc, eq, ilike, inArray } from "drizzle-orm";
import { Hono } from "hono";
import { getWaybookAccess, hasMinimumRole } from "../lib/access.js";
import { requireAuthMiddleware } from "../middleware/require-auth.js";
import type { AppBindings } from "../types.js";

export const lifecycleRoutes = new Hono<AppBindings>();

const stageOrder = ["destinations", "activities", "booking", "itinerary", "prep", "capture", "replay"] as const;
type Stage = (typeof stageOrder)[number];

const createActivityResearchCandidates = (destinationName: string, maxPerDestination: number) => {
  const seeds = [
    { title: `Top food walk in ${destinationName}`, provider: "GetYourGuide", confidence: 82, durationMin: 180 },
    { title: `${destinationName} sunset viewpoint`, provider: "Viator", confidence: 77, durationMin: 120 },
    { title: `Local nature adventure near ${destinationName}`, provider: "Klook", confidence: 74, durationMin: 240 },
    { title: `${destinationName} cultural highlights tour`, provider: "GetYourGuide", confidence: 79, durationMin: 210 },
    { title: `${destinationName} hidden gems route`, provider: "Viator", confidence: 71, durationMin: 150 }
  ];
  return seeds.slice(0, maxPerDestination);
};

const mapStageState = async (db: AppBindings["Variables"]["db"], waybookId: string, waybookStartDate: string, waybookEndDate: string) => {
  const [lockedDestinationCount] = await db
    .select({ value: count() })
    .from(schema.tripDestinations)
    .where(and(eq(schema.tripDestinations.waybookId, waybookId), eq(schema.tripDestinations.status, "locked")));

  const [lockedActivityCount] = await db
    .select({ value: count() })
    .from(schema.activityCandidates)
    .where(and(eq(schema.activityCandidates.waybookId, waybookId), eq(schema.activityCandidates.status, "locked")));

  const [confirmedStayCount] = await db
    .select({ value: count() })
    .from(schema.bookingRecords)
    .where(
      and(
        eq(schema.bookingRecords.waybookId, waybookId),
        eq(schema.bookingRecords.bookingStatus, "confirmed"),
        eq(schema.bookingRecords.type, "stay")
      )
    );

  const [confirmedActivityCount] = await db
    .select({ value: count() })
    .from(schema.bookingRecords)
    .where(
      and(
        eq(schema.bookingRecords.waybookId, waybookId),
        eq(schema.bookingRecords.bookingStatus, "confirmed"),
        eq(schema.bookingRecords.type, "activity")
      )
    );

  const [itineraryCount] = await db
    .select({ value: count() })
    .from(schema.itineraryEvents)
    .where(and(eq(schema.itineraryEvents.waybookId, waybookId), eq(schema.itineraryEvents.isAutoGenerated, true)));

  const [criticalRemainingCount] = await db
    .select({ value: count() })
    .from(schema.tripChecklistItems)
    .where(
      and(
        eq(schema.tripChecklistItems.waybookId, waybookId),
        eq(schema.tripChecklistItems.isCritical, true),
        inArray(schema.tripChecklistItems.status, ["todo", "in_progress"])
      )
    );

  const nowDate = new Date().toISOString().slice(0, 10);
  const isTripLive = nowDate >= waybookStartDate;
  const isTripEnded = nowDate > waybookEndDate;
  const lockedDestinationTotal = lockedDestinationCount?.value ?? 0;
  const lockedActivityTotal = lockedActivityCount?.value ?? 0;
  const confirmedStayTotal = confirmedStayCount?.value ?? 0;
  const confirmedActivityTotal = confirmedActivityCount?.value ?? 0;
  const itineraryTotal = itineraryCount?.value ?? 0;
  const criticalRemainingTotal = criticalRemainingCount?.value ?? 0;

  const stages: Array<{ stage: Stage; status: "locked" | "available" | "complete"; missingRequirements: string[] }> = [
    {
      stage: "destinations",
      status: lockedDestinationTotal > 0 ? "complete" : "available",
      missingRequirements: lockedDestinationTotal > 0 ? [] : ["Lock at least one destination."]
    },
    {
      stage: "activities",
      status: "locked",
      missingRequirements: []
    },
    {
      stage: "booking",
      status: "locked",
      missingRequirements: []
    },
    {
      stage: "itinerary",
      status: "locked",
      missingRequirements: []
    },
    {
      stage: "prep",
      status: "locked",
      missingRequirements: []
    },
    {
      stage: "capture",
      status: "locked",
      missingRequirements: []
    },
    {
      stage: "replay",
      status: "locked",
      missingRequirements: []
    }
  ];

  if (stages[0]?.status === "complete" && stages[1]) {
    stages[1].status = lockedActivityTotal >= 3 ? "complete" : "available";
    stages[1].missingRequirements = lockedActivityTotal >= 3 ? [] : ["Lock at least 3 activities."];
  }
  if (stages[1]?.status === "complete" && stages[2]) {
    const bookingReady = confirmedStayTotal >= 1 && confirmedActivityTotal >= 1;
    stages[2].status = bookingReady ? "complete" : "available";
    stages[2].missingRequirements = bookingReady ? [] : ["Confirm at least 1 stay and 1 activity booking."];
  }
  if (stages[2]?.status === "complete" && stages[3]) {
    stages[3].status = itineraryTotal > 0 ? "complete" : "available";
    stages[3].missingRequirements = itineraryTotal > 0 ? [] : ["Generate itinerary from your bookings and locked activities."];
  }
  if (stages[3]?.status === "complete" && stages[4]) {
    stages[4].status = criticalRemainingTotal === 0 ? "complete" : "available";
    stages[4].missingRequirements =
      criticalRemainingTotal === 0 ? [] : [`Complete ${criticalRemainingTotal} critical prep checklist items.`];
  }
  if (stages[4]?.status === "complete" && stages[5]) {
    stages[5].status = isTripLive ? "available" : "locked";
    stages[5].missingRequirements = isTripLive ? [] : ["Capture unlocks when trip start date is reached."];
  }
  if (stages[5] && isTripLive) {
    stages[5].status = "available";
    stages[5].missingRequirements = [];
  }
  if (stages[6]) {
    stages[6].status = isTripEnded ? "available" : "locked";
    stages[6].missingRequirements = isTripEnded ? [] : ["Replay unlocks after trip end date."];
  }

  const currentStage = stages.find((item) => item.status === "available")?.stage ?? "replay";

  return {
    currentStage,
    stages,
    meta: {
      lockedDestinations: lockedDestinationTotal,
      lockedActivities: lockedActivityTotal,
      confirmedStayBookings: confirmedStayTotal,
      confirmedActivityBookings: confirmedActivityTotal,
      autoGeneratedItineraryEvents: itineraryTotal,
      criticalPrepRemaining: criticalRemainingTotal
    }
  };
};

const mapDestination = (row: typeof schema.tripDestinations.$inferSelect, votes: { up: number; down: number }) => ({
  id: row.id,
  waybookId: row.waybookId,
  createdByUserId: row.createdByUserId,
  name: row.name,
  location:
    row.lat !== null && row.lng !== null
      ? {
          lat: row.lat,
          lng: row.lng,
          placeName: row.name
        }
      : null,
  placeId: row.placeId,
  rationale: row.rationale,
  status: row.status,
  votesUp: votes.up,
  votesDown: votes.down,
  lockedAt: row.lockedAt?.toISOString() ?? null,
  createdAt: row.createdAt.toISOString()
});

const mapActivityCandidate = (row: typeof schema.activityCandidates.$inferSelect, votes: { up: number; down: number }) => ({
  id: row.id,
  waybookId: row.waybookId,
  destinationId: row.destinationId,
  title: row.title,
  description: row.description,
  providerHint: row.providerHint,
  sourceUrl: row.sourceUrl,
  estimatedCostMin: row.estimatedCostMin,
  estimatedCostMax: row.estimatedCostMax,
  durationMin: row.durationMin,
  status: row.status,
  confidenceScore: row.confidenceScore,
  researchPayload: row.researchPayloadJson,
  votesUp: votes.up,
  votesDown: votes.down,
  createdAt: row.createdAt.toISOString()
});

lifecycleRoutes.get("/waybooks/:waybookId/stage-state", requireAuthMiddleware, async (c) => {
  const db = c.get("db");
  const user = c.get("user");
  const waybookId = c.req.param("waybookId");
  const access = await getWaybookAccess(db, waybookId, user.id);
  if (!access || !hasMinimumRole(access.role, "viewer")) return c.json({ error: "not_found" }, 404);

  const stageState = await mapStageState(db, waybookId, access.waybook.startDate, access.waybook.endDate);
  const [upserted] = await db
    .insert(schema.tripStageState)
    .values({
      waybookId,
      currentStage: stageState.currentStage,
      stageMetaJson: stageState.meta,
      updatedAt: new Date()
    })
    .onConflictDoUpdate({
      target: schema.tripStageState.waybookId,
      set: {
        currentStage: stageState.currentStage,
        stageMetaJson: stageState.meta,
        updatedAt: new Date()
      }
    })
    .returning();

  return c.json({
    waybookId,
    currentStage: stageState.currentStage,
    stages: stageState.stages,
    updatedAt: (upserted?.updatedAt ?? new Date()).toISOString()
  });
});

lifecycleRoutes.post("/waybooks/:waybookId/stage/recalculate", requireAuthMiddleware, async (c) => {
  const db = c.get("db");
  const user = c.get("user");
  const waybookId = c.req.param("waybookId");
  const access = await getWaybookAccess(db, waybookId, user.id);
  if (!access || !hasMinimumRole(access.role, "viewer")) return c.json({ error: "not_found" }, 404);
  const stageState = await mapStageState(db, waybookId, access.waybook.startDate, access.waybook.endDate);
  const [upserted] = await db
    .insert(schema.tripStageState)
    .values({
      waybookId,
      currentStage: stageState.currentStage,
      stageMetaJson: stageState.meta,
      updatedAt: new Date()
    })
    .onConflictDoUpdate({
      target: schema.tripStageState.waybookId,
      set: {
        currentStage: stageState.currentStage,
        stageMetaJson: stageState.meta,
        updatedAt: new Date()
      }
    })
    .returning();

  return c.json({
    waybookId,
    currentStage: stageState.currentStage,
    stages: stageState.stages,
    updatedAt: (upserted?.updatedAt ?? new Date()).toISOString()
  });
});

lifecycleRoutes.post("/waybooks/:waybookId/stage/advance", requireAuthMiddleware, async (c) => {
  const db = c.get("db");
  const user = c.get("user");
  const waybookId = c.req.param("waybookId");
  const access = await getWaybookAccess(db, waybookId, user.id);
  if (!access || !hasMinimumRole(access.role, "editor")) return c.json({ error: "not_found" }, 404);

  const state = await mapStageState(db, waybookId, access.waybook.startDate, access.waybook.endDate);
  const currentIndex = stageOrder.indexOf(state.currentStage);
  if (currentIndex < 0) return c.json({ error: "invalid_stage" }, 400);
  const current = state.stages[currentIndex];
  if (current?.status !== "complete") {
    return c.json({ error: "stage_not_complete", missingRequirements: current?.missingRequirements ?? [] }, 409);
  }
  const next = state.stages[currentIndex + 1];
  if (!next || next.status === "locked") return c.json({ error: "next_stage_locked", missingRequirements: next?.missingRequirements ?? [] }, 409);

  await db
    .insert(schema.tripStageState)
    .values({
      waybookId,
      currentStage: next.stage,
      stageMetaJson: state.meta,
      updatedAt: new Date()
    })
    .onConflictDoUpdate({
      target: schema.tripStageState.waybookId,
      set: { currentStage: next.stage, stageMetaJson: state.meta, updatedAt: new Date() }
    });

  return c.json({
    waybookId,
    currentStage: next.stage,
    stages: state.stages,
    updatedAt: new Date().toISOString()
  });
});

lifecycleRoutes.post(
  "/waybooks/:waybookId/destinations",
  requireAuthMiddleware,
  zValidator("json", createDestinationInputSchema),
  async (c) => {
    const db = c.get("db");
    const user = c.get("user");
    const waybookId = c.req.param("waybookId");
    const payload = c.req.valid("json");
    const access = await getWaybookAccess(db, waybookId, user.id);
    if (!access || !hasMinimumRole(access.role, "editor")) return c.json({ error: "not_found" }, 404);

    const [created] = await db
      .insert(schema.tripDestinations)
      .values({
        waybookId,
        createdByUserId: user.id,
        name: payload.name,
        lat: payload.location?.lat,
        lng: payload.location?.lng,
        placeId: payload.placeId ?? null,
        rationale: payload.rationale ?? null
      })
      .returning();

    if (!created) return c.json({ error: "create_failed" }, 500);
    return c.json(mapDestination(created, { up: 0, down: 0 }), 201);
  }
);

lifecycleRoutes.get("/waybooks/:waybookId/destinations", requireAuthMiddleware, async (c) => {
  const db = c.get("db");
  const user = c.get("user");
  const waybookId = c.req.param("waybookId");
  const access = await getWaybookAccess(db, waybookId, user.id);
  if (!access || !hasMinimumRole(access.role, "viewer")) return c.json({ error: "not_found" }, 404);

  const rows = await db
    .select()
    .from(schema.tripDestinations)
    .where(eq(schema.tripDestinations.waybookId, waybookId))
    .orderBy(desc(schema.tripDestinations.createdAt));
  const ids = rows.map((row) => row.id);
  const votes = ids.length
    ? await db.select().from(schema.destinationVotes).where(inArray(schema.destinationVotes.destinationId, ids))
    : [];
  const voteMap = new Map<string, { up: number; down: number }>();
  for (const vote of votes) {
    const current = voteMap.get(vote.destinationId) ?? { up: 0, down: 0 };
    if (vote.vote === "down") current.down += 1;
    else current.up += 1;
    voteMap.set(vote.destinationId, current);
  }
  return c.json({ items: rows.map((row) => mapDestination(row, voteMap.get(row.id) ?? { up: 0, down: 0 })) });
});

lifecycleRoutes.post(
  "/destinations/:destinationId/votes",
  requireAuthMiddleware,
  zValidator("json", createDestinationVoteInputSchema),
  async (c) => {
    const db = c.get("db");
    const user = c.get("user");
    const destinationId = c.req.param("destinationId");
    const payload = c.req.valid("json");

    const [destination] = await db.select().from(schema.tripDestinations).where(eq(schema.tripDestinations.id, destinationId)).limit(1);
    if (!destination) return c.json({ error: "not_found" }, 404);
    const access = await getWaybookAccess(db, destination.waybookId, user.id);
    if (!access || !hasMinimumRole(access.role, "viewer")) return c.json({ error: "not_found" }, 404);

    await db
      .insert(schema.destinationVotes)
      .values({ destinationId, userId: user.id, vote: payload.vote })
      .onConflictDoUpdate({
        target: [schema.destinationVotes.destinationId, schema.destinationVotes.userId],
        set: { vote: payload.vote, createdAt: new Date() }
      });
    return c.json({ success: true });
  }
);

lifecycleRoutes.post("/destinations/:destinationId/lock", requireAuthMiddleware, async (c) => {
  const db = c.get("db");
  const user = c.get("user");
  const destinationId = c.req.param("destinationId");
  const [destination] = await db.select().from(schema.tripDestinations).where(eq(schema.tripDestinations.id, destinationId)).limit(1);
  if (!destination) return c.json({ error: "not_found" }, 404);
  const access = await getWaybookAccess(db, destination.waybookId, user.id);
  if (!access || !hasMinimumRole(access.role, "editor")) return c.json({ error: "not_found" }, 404);
  await db
    .update(schema.tripDestinations)
    .set({ status: "locked", lockedAt: new Date() })
    .where(eq(schema.tripDestinations.id, destinationId));
  return c.json({ success: true });
});

lifecycleRoutes.post("/destinations/:destinationId/unlock", requireAuthMiddleware, async (c) => {
  const db = c.get("db");
  const user = c.get("user");
  const destinationId = c.req.param("destinationId");
  const [destination] = await db.select().from(schema.tripDestinations).where(eq(schema.tripDestinations.id, destinationId)).limit(1);
  if (!destination) return c.json({ error: "not_found" }, 404);
  const access = await getWaybookAccess(db, destination.waybookId, user.id);
  if (!access || !hasMinimumRole(access.role, "editor")) return c.json({ error: "not_found" }, 404);
  await db
    .update(schema.tripDestinations)
    .set({ status: "proposed", lockedAt: null })
    .where(eq(schema.tripDestinations.id, destinationId));
  return c.json({ success: true });
});

lifecycleRoutes.post(
  "/waybooks/:waybookId/activities/research",
  requireAuthMiddleware,
  zValidator("json", runActivityResearchInputSchema),
  async (c) => {
    const db = c.get("db");
    const user = c.get("user");
    const waybookId = c.req.param("waybookId");
    const payload = c.req.valid("json");
    const access = await getWaybookAccess(db, waybookId, user.id);
    if (!access || !hasMinimumRole(access.role, "editor")) return c.json({ error: "not_found" }, 404);

    const destinations = await db
      .select()
      .from(schema.tripDestinations)
      .where(and(eq(schema.tripDestinations.waybookId, waybookId), eq(schema.tripDestinations.status, "locked")));
    if (!destinations.length) return c.json({ error: "no_locked_destinations" }, 409);

    for (const destination of destinations) {
      const candidates = createActivityResearchCandidates(destination.name, payload.maxPerDestination);
      for (const candidate of candidates) {
        const [exists] = await db
          .select()
          .from(schema.activityCandidates)
          .where(
            and(
              eq(schema.activityCandidates.waybookId, waybookId),
              eq(schema.activityCandidates.destinationId, destination.id),
              ilike(schema.activityCandidates.title, candidate.title)
            )
          )
          .limit(1);
        if (exists) continue;
        await db.insert(schema.activityCandidates).values({
          waybookId,
          destinationId: destination.id,
          title: candidate.title,
          description: `AI-ranked option for ${destination.name}.`,
          providerHint: candidate.provider,
          sourceUrl: `https://www.google.com/search?q=${encodeURIComponent(candidate.title)}`,
          estimatedCostMin: 3000,
          estimatedCostMax: 12000,
          durationMin: candidate.durationMin,
          status: "suggested",
          confidenceScore: candidate.confidence,
          researchPayloadJson: {
            rationale: "Matched destination popularity, logistics fit, and provider availability.",
            destination: destination.name
          }
        });
      }
    }

    const rows = await db
      .select()
      .from(schema.activityCandidates)
      .where(eq(schema.activityCandidates.waybookId, waybookId))
      .orderBy(desc(schema.activityCandidates.createdAt));

    const ids = rows.map((row) => row.id);
    const votes = ids.length ? await db.select().from(schema.activityVotes).where(inArray(schema.activityVotes.activityCandidateId, ids)) : [];
    const voteMap = new Map<string, { up: number; down: number }>();
    for (const vote of votes) {
      const current = voteMap.get(vote.activityCandidateId) ?? { up: 0, down: 0 };
      if (vote.vote === "down") current.down += 1;
      else current.up += 1;
      voteMap.set(vote.activityCandidateId, current);
    }

    return c.json({ items: rows.map((row) => mapActivityCandidate(row, voteMap.get(row.id) ?? { up: 0, down: 0 })) });
  }
);

lifecycleRoutes.get("/waybooks/:waybookId/activities", requireAuthMiddleware, async (c) => {
  const db = c.get("db");
  const user = c.get("user");
  const waybookId = c.req.param("waybookId");
  const access = await getWaybookAccess(db, waybookId, user.id);
  if (!access || !hasMinimumRole(access.role, "viewer")) return c.json({ error: "not_found" }, 404);
  const rows = await db
    .select()
    .from(schema.activityCandidates)
    .where(eq(schema.activityCandidates.waybookId, waybookId))
    .orderBy(desc(schema.activityCandidates.createdAt));
  const ids = rows.map((row) => row.id);
  const votes = ids.length ? await db.select().from(schema.activityVotes).where(inArray(schema.activityVotes.activityCandidateId, ids)) : [];
  const voteMap = new Map<string, { up: number; down: number }>();
  for (const vote of votes) {
    const current = voteMap.get(vote.activityCandidateId) ?? { up: 0, down: 0 };
    if (vote.vote === "down") current.down += 1;
    else current.up += 1;
    voteMap.set(vote.activityCandidateId, current);
  }
  return c.json({ items: rows.map((row) => mapActivityCandidate(row, voteMap.get(row.id) ?? { up: 0, down: 0 })) });
});

lifecycleRoutes.post(
  "/activities/:activityId/votes",
  requireAuthMiddleware,
  zValidator("json", createActivityVoteInputSchema),
  async (c) => {
    const db = c.get("db");
    const user = c.get("user");
    const activityId = c.req.param("activityId");
    const payload = c.req.valid("json");
    const [activity] = await db.select().from(schema.activityCandidates).where(eq(schema.activityCandidates.id, activityId)).limit(1);
    if (!activity) return c.json({ error: "not_found" }, 404);
    const access = await getWaybookAccess(db, activity.waybookId, user.id);
    if (!access || !hasMinimumRole(access.role, "viewer")) return c.json({ error: "not_found" }, 404);
    await db
      .insert(schema.activityVotes)
      .values({ activityCandidateId: activityId, userId: user.id, vote: payload.vote })
      .onConflictDoUpdate({
        target: [schema.activityVotes.activityCandidateId, schema.activityVotes.userId],
        set: { vote: payload.vote, createdAt: new Date() }
      });
    return c.json({ success: true });
  }
);

const updateActivityStatus = async (c: any, status: "shortlisted" | "locked" | "suggested" | "discarded") => {
  const db = c.get("db");
  const user = c.get("user");
  const activityId = c.req.param("activityId");
  const [activity] = await db.select().from(schema.activityCandidates).where(eq(schema.activityCandidates.id, activityId)).limit(1);
  if (!activity) return c.json({ error: "not_found" }, 404);
  const access = await getWaybookAccess(db, activity.waybookId, user.id);
  if (!access || !hasMinimumRole(access.role, "editor")) return c.json({ error: "not_found" }, 404);
  await db.update(schema.activityCandidates).set({ status }).where(eq(schema.activityCandidates.id, activityId));
  return c.json({ success: true });
};

lifecycleRoutes.post("/activities/:activityId/lock", requireAuthMiddleware, async (c) => updateActivityStatus(c, "locked"));
lifecycleRoutes.post("/activities/:activityId/shortlist", requireAuthMiddleware, async (c) => updateActivityStatus(c, "shortlisted"));
lifecycleRoutes.post(
  "/activities/:activityId/status",
  requireAuthMiddleware,
  zValidator("json", updateActivityStatusInputSchema),
  async (c) => updateActivityStatus(c, c.req.valid("json").status)
);

lifecycleRoutes.post(
  "/waybooks/:waybookId/stays/recommend",
  requireAuthMiddleware,
  zValidator("json", staysRecommendInputSchema),
  async (c) => {
    const db = c.get("db");
    const user = c.get("user");
    const waybookId = c.req.param("waybookId");
    const access = await getWaybookAccess(db, waybookId, user.id);
    if (!access || !hasMinimumRole(access.role, "viewer")) return c.json({ error: "not_found" }, 404);

    const destinations = await db
      .select()
      .from(schema.tripDestinations)
      .where(and(eq(schema.tripDestinations.waybookId, waybookId), eq(schema.tripDestinations.status, "locked")));
    const items = destinations.flatMap((destination, idx) => [
      {
        id: `${destination.id}-stay-1`,
        title: `${destination.name} central stay`,
        location: destination.name,
        provider: "Booking.com",
        sourceUrl: `https://www.booking.com/searchresults.html?ss=${encodeURIComponent(destination.name)}`,
        estimatedNightlyCostMin: 9000 + idx * 2000,
        estimatedNightlyCostMax: 22000 + idx * 2000,
        rationale: "Close to shortlisted activity clusters and transit access."
      },
      {
        id: `${destination.id}-stay-2`,
        title: `${destination.name} value hostel`,
        location: destination.name,
        provider: "Hostelworld",
        sourceUrl: `https://www.hostelworld.com/st/hostels/?q=${encodeURIComponent(destination.name)}`,
        estimatedNightlyCostMin: 3500 + idx * 1000,
        estimatedNightlyCostMax: 9000 + idx * 1000,
        rationale: "Budget-friendly option with high location convenience."
      }
    ]);

    return c.json({ items });
  }
);

lifecycleRoutes.post(
  "/bookings/:bookingId/embedded-checkout-session",
  requireAuthMiddleware,
  zValidator("json", embeddedCheckoutSessionInputSchema),
  async (c) => {
    const db = c.get("db");
    const user = c.get("user");
    const bookingId = c.req.param("bookingId");
    const payload = c.req.valid("json");
    const [booking] = await db.select().from(schema.bookingRecords).where(eq(schema.bookingRecords.id, bookingId)).limit(1);
    if (!booking) return c.json({ error: "not_found" }, 404);
    const access = await getWaybookAccess(db, booking.waybookId, user.id);
    if (!access || !hasMinimumRole(access.role, "editor")) return c.json({ error: "not_found" }, 404);

    const providerReference = `emb_${crypto.randomUUID()}`;
    const checkoutUrl =
      booking.checkoutUrl ??
      `${payload.returnUrl}?bookingId=${bookingId}&providerRef=${providerReference}&type=embedded_checkout`;

    await db
      .update(schema.bookingRecords)
      .set({
        checkoutUrl,
        providerBookingId: providerReference,
        bookingStatus: "pending_checkout",
        updatedAt: new Date()
      })
      .where(eq(schema.bookingRecords.id, bookingId));

    return c.json({ checkoutUrl, providerReference });
  }
);

lifecycleRoutes.post(
  "/bookings/:bookingId/embedded-checkout-complete",
  requireAuthMiddleware,
  zValidator("json", embeddedCheckoutCompleteInputSchema),
  async (c) => {
    const db = c.get("db");
    const user = c.get("user");
    const bookingId = c.req.param("bookingId");
    const payload = c.req.valid("json");
    const [booking] = await db.select().from(schema.bookingRecords).where(eq(schema.bookingRecords.id, bookingId)).limit(1);
    if (!booking) return c.json({ error: "not_found" }, 404);
    const access = await getWaybookAccess(db, booking.waybookId, user.id);
    if (!access || !hasMinimumRole(access.role, "editor")) return c.json({ error: "not_found" }, 404);

    await db
      .update(schema.bookingRecords)
      .set({
        providerBookingId: payload.providerReference,
        bookingStatus: payload.status,
        confirmationCode: payload.confirmationCode ?? booking.confirmationCode,
        updatedAt: new Date()
      })
      .where(eq(schema.bookingRecords.id, bookingId));
    return c.json({ success: true });
  }
);

lifecycleRoutes.post("/waybooks/:waybookId/itinerary/generate", requireAuthMiddleware, async (c) => {
  const db = c.get("db");
  const user = c.get("user");
  const waybookId = c.req.param("waybookId");
  const access = await getWaybookAccess(db, waybookId, user.id);
  if (!access || !hasMinimumRole(access.role, "editor")) return c.json({ error: "not_found" }, 404);

  const [maxVersionRow] = await db
    .select({ value: count() })
    .from(schema.itineraryEvents)
    .where(and(eq(schema.itineraryEvents.waybookId, waybookId), eq(schema.itineraryEvents.isAutoGenerated, true)));
  const generationVersion = (maxVersionRow?.value ?? 0) + 1;

  await db
    .delete(schema.itineraryEvents)
    .where(and(eq(schema.itineraryEvents.waybookId, waybookId), eq(schema.itineraryEvents.isAutoGenerated, true)));

  const bookings = await db
    .select()
    .from(schema.bookingRecords)
    .where(and(eq(schema.bookingRecords.waybookId, waybookId), eq(schema.bookingRecords.bookingStatus, "confirmed")))
    .orderBy(asc(schema.bookingRecords.bookedForStart));
  let generatedCount = 0;

  for (const booking of bookings) {
    const start = booking.bookedForStart ?? new Date(`${access.waybook.startDate}T10:00:00.000Z`);
    await db.insert(schema.itineraryEvents).values({
      waybookId,
      bookingRecordId: booking.id,
      title: booking.title,
      startTime: start,
      endTime: booking.bookedForEnd,
      isAutoGenerated: true,
      generationVersion,
      lockedByBooking: true,
      ownerUserId: booking.bookedByUserId
    });
    generatedCount += 1;
  }

  const lockedActivities = await db
    .select()
    .from(schema.activityCandidates)
    .where(and(eq(schema.activityCandidates.waybookId, waybookId), eq(schema.activityCandidates.status, "locked")));
  let offsetHours = 0;
  for (const activity of lockedActivities) {
    const start = new Date(`${access.waybook.startDate}T12:00:00.000Z`);
    start.setUTCHours(start.getUTCHours() + offsetHours);
    offsetHours += 3;
    await db.insert(schema.itineraryEvents).values({
      waybookId,
      title: activity.title,
      startTime: start,
      endTime: null,
      isAutoGenerated: true,
      generationVersion,
      lockedByBooking: false
    });
    generatedCount += 1;
  }

  return c.json({ generatedCount, generationVersion });
});

lifecycleRoutes.get("/waybooks/:waybookId/itinerary", requireAuthMiddleware, async (c) => {
  const db = c.get("db");
  const user = c.get("user");
  const waybookId = c.req.param("waybookId");
  const access = await getWaybookAccess(db, waybookId, user.id);
  if (!access || !hasMinimumRole(access.role, "viewer")) return c.json({ error: "not_found" }, 404);
  const items = await db.select().from(schema.itineraryEvents).where(eq(schema.itineraryEvents.waybookId, waybookId)).orderBy(asc(schema.itineraryEvents.startTime));
  return c.json({
    items: items.map((row) => ({
      id: row.id,
      waybookId: row.waybookId,
      planningItemId: row.planningItemId,
      bookingRecordId: row.bookingRecordId,
      title: row.title,
      startTime: row.startTime.toISOString(),
      endTime: row.endTime?.toISOString() ?? null,
      bufferBeforeMin: row.bufferBeforeMin,
      bufferAfterMin: row.bufferAfterMin,
      ownerUserId: row.ownerUserId,
      notes: row.notes,
      createdAt: row.createdAt.toISOString(),
      updatedAt: row.updatedAt.toISOString(),
      isAutoGenerated: row.isAutoGenerated,
      generationVersion: row.generationVersion,
      lockedByBooking: row.lockedByBooking
    }))
  });
});

lifecycleRoutes.get("/waybooks/:waybookId/checklist", requireAuthMiddleware, async (c) => {
  const db = c.get("db");
  const user = c.get("user");
  const waybookId = c.req.param("waybookId");
  const access = await getWaybookAccess(db, waybookId, user.id);
  if (!access || !hasMinimumRole(access.role, "viewer")) return c.json({ error: "not_found" }, 404);
  const items = await db
    .select()
    .from(schema.tripChecklistItems)
    .where(eq(schema.tripChecklistItems.waybookId, waybookId))
    .orderBy(asc(schema.tripChecklistItems.dueAt), desc(schema.tripChecklistItems.isCritical));
  return c.json({
    items: items.map((row) => ({
      id: row.id,
      waybookId: row.waybookId,
      title: row.title,
      category: row.category,
      isCritical: row.isCritical,
      assignedUserId: row.assignedUserId,
      dueAt: row.dueAt?.toISOString() ?? null,
      status: row.status,
      notes: row.notes,
      createdAt: row.createdAt.toISOString(),
      updatedAt: row.updatedAt.toISOString()
    }))
  });
});

lifecycleRoutes.post(
  "/waybooks/:waybookId/checklist",
  requireAuthMiddleware,
  zValidator("json", createChecklistItemInputSchema),
  async (c) => {
    const db = c.get("db");
    const user = c.get("user");
    const waybookId = c.req.param("waybookId");
    const payload = c.req.valid("json");
    const access = await getWaybookAccess(db, waybookId, user.id);
    if (!access || !hasMinimumRole(access.role, "editor")) return c.json({ error: "not_found" }, 404);
    const [created] = await db
      .insert(schema.tripChecklistItems)
      .values({
        waybookId,
        title: payload.title,
        category: payload.category ?? null,
        isCritical: payload.isCritical ?? false,
        assignedUserId: payload.assignedUserId ?? null,
        dueAt: payload.dueAt ? new Date(payload.dueAt) : null,
        status: payload.status ?? "todo",
        notes: payload.notes ?? null
      })
      .returning();
    if (!created) return c.json({ error: "create_failed" }, 500);
    return c.json({
      id: created.id,
      waybookId: created.waybookId,
      title: created.title,
      category: created.category,
      isCritical: created.isCritical,
      assignedUserId: created.assignedUserId,
      dueAt: created.dueAt?.toISOString() ?? null,
      status: created.status,
      notes: created.notes,
      createdAt: created.createdAt.toISOString(),
      updatedAt: created.updatedAt.toISOString()
    }, 201);
  }
);

lifecycleRoutes.patch(
  "/checklist/:itemId",
  requireAuthMiddleware,
  zValidator("json", updateChecklistItemInputSchema),
  async (c) => {
    const db = c.get("db");
    const user = c.get("user");
    const itemId = c.req.param("itemId");
    const payload = c.req.valid("json");
    const [item] = await db.select().from(schema.tripChecklistItems).where(eq(schema.tripChecklistItems.id, itemId)).limit(1);
    if (!item) return c.json({ error: "not_found" }, 404);
    const access = await getWaybookAccess(db, item.waybookId, user.id);
    if (!access || !hasMinimumRole(access.role, "editor")) return c.json({ error: "not_found" }, 404);
    const [updated] = await db
      .update(schema.tripChecklistItems)
      .set({
        title: payload.title,
        category: payload.category,
        isCritical: payload.isCritical,
        assignedUserId: payload.assignedUserId,
        dueAt: payload.dueAt ? new Date(payload.dueAt) : payload.dueAt === null ? null : undefined,
        status: payload.status,
        notes: payload.notes,
        updatedAt: new Date()
      })
      .where(eq(schema.tripChecklistItems.id, itemId))
      .returning();
    if (!updated) return c.json({ error: "not_found" }, 404);
    return c.json({
      id: updated.id,
      waybookId: updated.waybookId,
      title: updated.title,
      category: updated.category,
      isCritical: updated.isCritical,
      assignedUserId: updated.assignedUserId,
      dueAt: updated.dueAt?.toISOString() ?? null,
      status: updated.status,
      notes: updated.notes,
      createdAt: updated.createdAt.toISOString(),
      updatedAt: updated.updatedAt.toISOString()
    });
  }
);

lifecycleRoutes.get("/waybooks/:waybookId/readiness-score", requireAuthMiddleware, async (c) => {
  const db = c.get("db");
  const user = c.get("user");
  const waybookId = c.req.param("waybookId");
  const access = await getWaybookAccess(db, waybookId, user.id);
  if (!access || !hasMinimumRole(access.role, "viewer")) return c.json({ error: "not_found" }, 404);
  const [criticalRemainingCount] = await db
    .select({ value: count() })
    .from(schema.tripChecklistItems)
    .where(
      and(
        eq(schema.tripChecklistItems.waybookId, waybookId),
        eq(schema.tripChecklistItems.isCritical, true),
        inArray(schema.tripChecklistItems.status, ["todo", "in_progress"])
      )
    );
  const [totalRemainingCount] = await db
    .select({ value: count() })
    .from(schema.tripChecklistItems)
    .where(and(eq(schema.tripChecklistItems.waybookId, waybookId), inArray(schema.tripChecklistItems.status, ["todo", "in_progress"])));
  const daysUntilTrip = Math.ceil((new Date(`${access.waybook.startDate}T00:00:00Z`).getTime() - Date.now()) / (1000 * 60 * 60 * 24));
  const criticalRemainingTotal = criticalRemainingCount?.value ?? 0;
  const totalRemainingTotal = totalRemainingCount?.value ?? 0;
  const score = Math.max(0, 100 - criticalRemainingTotal * 20 - totalRemainingTotal * 5);
  return c.json({
    score,
    criticalRemaining: criticalRemainingTotal,
    totalRemaining: totalRemainingTotal,
    daysUntilTrip
  });
});

lifecycleRoutes.get("/waybooks/:waybookId/messages", requireAuthMiddleware, async (c) => {
  const db = c.get("db");
  const user = c.get("user");
  const waybookId = c.req.param("waybookId");
  const scope = (c.req.query("scope") || "trip") as "trip" | "dm";
  const threadKey = c.req.query("threadKey");
  const access = await getWaybookAccess(db, waybookId, user.id);
  if (!access || !hasMinimumRole(access.role, "viewer")) return c.json({ error: "not_found" }, 404);

  const where = threadKey
    ? and(eq(schema.tripMessages.waybookId, waybookId), eq(schema.tripMessages.scope, scope), eq(schema.tripMessages.threadKey, threadKey))
    : and(
        eq(schema.tripMessages.waybookId, waybookId),
        eq(schema.tripMessages.scope, scope),
        eq(schema.tripMessages.threadKey, scope === "trip" ? "trip:main" : `dm:${user.id}`)
      );
  const items = await db.select().from(schema.tripMessages).where(where).orderBy(asc(schema.tripMessages.createdAt));
  return c.json({
    items: items.map((row) => ({
      id: row.id,
      waybookId: row.waybookId,
      scope: row.scope,
      threadKey: row.threadKey,
      senderUserId: row.senderUserId,
      body: row.body,
      createdAt: row.createdAt.toISOString()
    }))
  });
});

lifecycleRoutes.post(
  "/waybooks/:waybookId/messages",
  requireAuthMiddleware,
  zValidator("json", createTripMessageInputSchema),
  async (c) => {
    const db = c.get("db");
    const user = c.get("user");
    const waybookId = c.req.param("waybookId");
    const payload = c.req.valid("json");
    const access = await getWaybookAccess(db, waybookId, user.id);
    if (!access || !hasMinimumRole(access.role, "viewer")) return c.json({ error: "not_found" }, 404);

    const normalizedThreadKey = payload.scope === "trip" ? "trip:main" : payload.threadKey;
    const [created] = await db
      .insert(schema.tripMessages)
      .values({
        waybookId,
        scope: payload.scope,
        threadKey: normalizedThreadKey,
        senderUserId: user.id,
        body: payload.body
      })
      .returning();
    if (!created) return c.json({ error: "create_failed" }, 500);

    const members = await db.select().from(schema.waybookMembers).where(eq(schema.waybookMembers.waybookId, waybookId));
    if (members.length) {
      await db.insert(schema.tripMessageReceipts).values(
        members.map((member) => ({
          messageId: created.id,
          userId: member.userId,
          status: (member.userId === user.id ? "read" : "sent") as "read" | "sent",
          readAt: member.userId === user.id ? new Date() : null
        }))
      );
    }

    return c.json({
      id: created.id,
      waybookId: created.waybookId,
      scope: created.scope,
      threadKey: created.threadKey,
      senderUserId: created.senderUserId,
      body: created.body,
      createdAt: created.createdAt.toISOString()
    }, 201);
  }
);

lifecycleRoutes.post("/messages/:messageId/read", requireAuthMiddleware, async (c) => {
  const db = c.get("db");
  const user = c.get("user");
  const messageId = c.req.param("messageId");
  const [message] = await db.select().from(schema.tripMessages).where(eq(schema.tripMessages.id, messageId)).limit(1);
  if (!message) return c.json({ error: "not_found" }, 404);
  const access = await getWaybookAccess(db, message.waybookId, user.id);
  if (!access || !hasMinimumRole(access.role, "viewer")) return c.json({ error: "not_found" }, 404);
  await db
    .insert(schema.tripMessageReceipts)
    .values({
      messageId,
      userId: user.id,
      status: "read",
      readAt: new Date()
    })
    .onConflictDoUpdate({
      target: [schema.tripMessageReceipts.messageId, schema.tripMessageReceipts.userId],
      set: { status: "read", readAt: new Date() }
    });
  return c.json({ success: true });
});

lifecycleRoutes.get("/waybooks/:waybookId/dm-threads", requireAuthMiddleware, async (c) => {
  const db = c.get("db");
  const user = c.get("user");
  const waybookId = c.req.param("waybookId");
  const access = await getWaybookAccess(db, waybookId, user.id);
  if (!access || !hasMinimumRole(access.role, "viewer")) return c.json({ error: "not_found" }, 404);
  const rows = await db
    .select()
    .from(schema.tripMessages)
    .where(and(eq(schema.tripMessages.waybookId, waybookId), eq(schema.tripMessages.scope, "dm")))
    .orderBy(desc(schema.tripMessages.createdAt));
  const threadMap = new Map<string, { threadKey: string; participantIds: string[]; lastMessageAt: string | null }>();
  for (const row of rows) {
    if (!row.threadKey.includes(user.id)) continue;
    if (threadMap.has(row.threadKey)) continue;
    const participantIds = row.threadKey
      .replace(/^dm:/, "")
      .split(":")
      .filter(Boolean);
    threadMap.set(row.threadKey, {
      threadKey: row.threadKey,
      participantIds,
      lastMessageAt: row.createdAt.toISOString()
    });
  }
  return c.json({ items: Array.from(threadMap.values()) });
});
